<!DOCTYPE html>
<html lang="ko" data-theme="dark-kernel">
<head>
<!-- BEGIN: Google adsense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2110881342960271" crossorigin="anonymous"></script>
<!-- END: Google adsense -->
<!-- BEGIN: Google adsense repair -->
<script async src="https://fundingchoicesmessages.google.com/i/pub-2110881342960271?ers=1" nonce="laI6FT8gpRxugDJv5AGJRA"></script><script nonce="laI6FT8gpRxugDJv5AGJRA">(function() {function signalGooglefcPresent() {if (!window.frames['googlefcPresent']) {if (document.body) {const iframe = document.createElement('iframe'); iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;'; iframe.style.display = 'none'; iframe.name = 'googlefcPresent'; document.body.appendChild(iframe);} else {setTimeout(signalGooglefcPresent, 0);}}}signalGooglefcPresent();})();</script>
<!-- END: Google adsense repair -->
<!-- BEGIN: Google analytics -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1VWQF060SX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1VWQF060SX');
</script>
<!-- END: Google analytics -->

<script>
(function(){var m=document.cookie.match(/claude_theme=([^;]+)/);if(m)document.documentElement.setAttribute('data-theme',m[1]);})();
</script>
<meta charset="UTF-8">
<meta property="og:type" content="article">
<meta property="og:site_name" content="AI Vibe Coding 가이드 /with MINZKN">
<meta property="og:title" content="자주 묻는 질문 (FAQ)">
<meta property="og:description" content="자주 묻는 질문 (FAQ): A: Claude는 Anthropic이 개발한 AI 어시스턴트로, 다음과 같은 특징이 있습니다:">
<meta property="og:url" content="https://minzkn.com/claude/pages/faq.html">
<meta property="og:image" content="https://minzkn.com/claude/images/og-image.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="자주 묻는 질문 (FAQ): A: Claude는 Anthropic이 개발한 AI 어시스턴트로, 다음과 같은 특징이 있습니다:">
<meta name="keywords" content="Claude, AI, LLM, 자주 묻는 질문 (FAQ), 일반적인 질문, 기술적 질문, 문제 해결, Claude Code 관련 질문">
<meta name="author" content="MINZKN">
<title>자주 묻는 질문 (FAQ) - AI Vibe Coding 가이드 /with MINZKN</title>
<link rel="icon" type="image/svg+xml" href="../images/favicon.svg">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css">
<link rel="stylesheet" href="../css/themes.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/responsive.css">
</head>
<body>
<div class="page-wrapper">
<header class="site-header"></header>
<nav class="side-nav" aria-label="사이트 내비게이션"></nav>
<main class="main-content">
<nav class="breadcrumb"></nav>

<article>
<h1>자주 묻는 질문 (FAQ)</h1>

<div class="info-box warning">
  <strong>업데이트 안내:</strong> 모델/요금/버전/정책 등 시점에 민감한 정보는 변동될 수 있습니다.
  최신 내용은 공식 문서를 확인하세요.
</div>

<section>
<h2 id="general">일반적인 질문</h2>

<div class="faq-item">
<h3 id="what-is-difference">Q1. Claude와 ChatGPT의 차이점은 무엇인가요?</h3>
<p><strong>A:</strong> Claude는 Anthropic이 개발한 AI 어시스턴트로, 다음과 같은 특징이 있습니다:</p>
<ul>
<li><strong>긴 컨텍스트 윈도우:</strong> 긴 문서/대화 처리를 위한 넓은 입력 범위</li>
<li><strong>안전성 중심 설계:</strong> 안전을 고려한 정책과 가드레일</li>
<li><strong>정확한 지시 따르기:</strong> 복잡한 구조화된 출력에 강점</li>
<li><strong>코드 생성 능력:</strong> 코드 품질과 지시 준수에 강점</li>
<li><strong>최신 지식:</strong> 모델/버전에 따라 범위가 다르므로 공식 문서 확인</li>
</ul>
</div>

<div class="faq-item">
<h3 id="which-model">Q2. 어떤 모델을 선택해야 하나요?</h3>
<p><strong>A:</strong> 사용 사례에 따라 선택하세요:</p>
<ul>
<li><strong>고성능 티어:</strong> 복잡한 분석, 고급 추론, 연구 작업</li>
<li><strong>균형 티어:</strong> 대부분의 일반적인 사용 사례와 코딩</li>
<li><strong>경량 티어:</strong> 빠른 응답, 간단한 작업, 대량 처리</li>
</ul>
<p>대부분의 경우 균형 티어로 시작하고, 필요에 따라 조정하는 것을 권장합니다.</p>
</div>

<div class="faq-item">
<h3 id="how-much-cost">Q3. 비용이 얼마나 드나요?</h3>
<p><strong>A:</strong> 토큰 사용량에 따라 과금됩니다:</p>
<p>요금은 입력/출력 토큰, 선택한 티어, 캐싱 사용 여부에 따라 달라집니다. 최신 요금표는 공식 문서를 확인하세요.</p>
</div>

<div class="faq-item">
<h3 id="get-api-key">Q4. API 키는 어떻게 발급받나요?</h3>
<p><strong>A:</strong> 다음 단계를 따르세요:</p>
<ol>
<li><a href="https://console.anthropic.com" target="_blank">Anthropic Console</a> 방문</li>
<li>계정 생성 또는 로그인</li>
<li>Settings → API Keys 메뉴 선택</li>
<li>"Create Key" 버튼 클릭</li>
<li>키 이름 입력 후 생성</li>
<li>표시된 키를 안전한 곳에 저장 (재확인 불가)</li>
</ol>
<p><strong>주의:</strong> API 키는 한 번만 표시되므로 반드시 저장하세요. 노출되면 즉시 삭제하고 재발급받으세요.</p>
</div>

<div class="faq-item">
<h3 id="free-tier">Q5. 무료 체험이 가능한가요?</h3>
<p><strong>A:</strong> Anthropic은 신규 가입자에게 초기 크레딧을 제공합니다. Claude.ai 웹 인터페이스는 무료 플랜(Pro 플랜도 있음)이 있지만, API는 사용량에 따라 과금됩니다. 테스트 목적으로는 Haiku 모델을 사용하면 비용을 최소화할 수 있습니다.</p>
</div>
</section>

<section>
<h2 id="technical">기술적 질문</h2>

<div class="faq-item">
<h3 id="token-limit">Q6. 컨텍스트 윈도우가 200K 토큰인데, 실제로는 더 적게 사용되는 것 같아요.</h3>
<p><strong>A:</strong> 몇 가지 이유가 있습니다:</p>
<ul>
<li><strong>출력 토큰 제한:</strong> 최대 출력은 모델에 따라 4K-8K 토큰으로 제한됩니다.</li>
<li><strong>시스템 프롬프트:</strong> 시스템 프롬프트도 컨텍스트에 포함됩니다.</li>
<li><strong>토큰 계산 방식:</strong> 실제 텍스트 길이와 토큰 수는 다릅니다.</li>
</ul>
<pre><code><span class="cmt"># 토큰 수 계산 예시 (Python SDK)</span>
<span class="kw">import</span> anthropic

client = anthropic.Anthropic(api_key=<span class="str">"your-api-key"</span>)
token_count = client.count_tokens(<span class="str">"Hello, Claude!"</span>)
<span class="fn">print</span>(f<span class="str">"토큰 수: {token_count}"</span>)  <span class="cmt"># 3-4 토큰</span></code></pre>
</div>

<div class="faq-item">
<h3 id="streaming">Q7. 스트리밍 응답을 사용해야 하나요?</h3>
<p><strong>A:</strong> 사용자 경험을 개선하려면 스트리밍을 권장합니다:</p>
<ul>
<li><strong>장점:</strong> 실시간 피드백, 긴 응답에서 빠른 첫 토큰, 사용자 대기 시간 단축</li>
<li><strong>단점:</strong> 구현 복잡도 증가, 에러 핸들링 어려움</li>
<li><strong>권장 사용:</strong> 챗봇, 대화형 UI, 긴 텍스트 생성</li>
<li><strong>불필요한 경우:</strong> 배치 처리, 자동화 스크립트, 구조화된 데이터 추출</li>
</ul>
<pre><code><span class="cmt"># Python 스트리밍 예시</span>
<span class="kw">with</span> client.messages.stream(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1024</span>,
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"긴 이야기를 써주세요"</span>}]
) <span class="kw">as</span> stream:
    <span class="kw">for</span> text <span class="kw">in</span> stream.text_stream:
        <span class="fn">print</span>(text, end=<span class="str">""</span>, flush=<span class="num">True</span>)</code></pre>
</div>

<div class="faq-item">
<h3 id="json-mode">Q8. JSON 형식으로 응답을 받고 싶어요. JSON 모드가 있나요?</h3>
<p><strong>A:</strong> Claude API에는 별도의 JSON 모드가 없지만, 프롬프트로 구조화된 출력을 얻을 수 있습니다:</p>
<pre><code>system_prompt = <span class="str">"""당신은 데이터를 JSON 형식으로 추출하는 어시스턴트입니다.
항상 유효한 JSON만 출력하세요. 추가 설명이나 마크다운은 포함하지 마세요.

출력 형식:
{
  "name": "문자열",
  "age": 숫자,
  "email": "문자열"
}"""</span>

response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1024</span>,
    system=system_prompt,
    messages=[{
        <span class="str">"role"</span>: <span class="str">"user"</span>,
        <span class="str">"content"</span>: <span class="str">"이름: 홍길동, 나이: 30세, 연락처: hong@example.com"</span>
    }]
)

<span class="kw">import</span> json
data = json.loads(response.content[<span class="num">0</span>].text)</code></pre>
<p><strong>팁:</strong> 더 안정적인 파싱을 위해 XML 태그나 Pydantic 모델을 사용할 수도 있습니다.</p>
</div>

<div class="faq-item">
<h3 id="tools-difference">Q9. Tool Use와 Function Calling의 차이점은?</h3>
<p><strong>A:</strong> 같은 개념입니다. Anthropic은 "Tool Use"라는 용어를 사용하고, OpenAI는 "Function Calling"이라고 부릅니다. Claude의 Tool Use는:</p>
<ul>
<li>외부 API 호출 (검색, 데이터베이스 쿼리)</li>
<li>계산 수행 (수학, 데이터 처리)</li>
<li>파일 시스템 작업</li>
</ul>
<p>등의 작업을 Claude가 요청할 수 있게 합니다. 실제 실행은 개발자가 처리합니다.</p>
<pre><code>tools = [{
    <span class="str">"name"</span>: <span class="str">"get_weather"</span>,
    <span class="str">"description"</span>: <span class="str">"특정 도시의 현재 날씨를 가져옵니다"</span>,
    <span class="str">"input_schema"</span>: {
        <span class="str">"type"</span>: <span class="str">"object"</span>,
        <span class="str">"properties"</span>: {
            <span class="str">"city"</span>: {<span class="str">"type"</span>: <span class="str">"string"</span>, <span class="str">"description"</span>: <span class="str">"도시 이름"</span>}
        },
        <span class="str">"required"</span>: [<span class="str">"city"</span>]
    }
}]

response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1024</span>,
    tools=tools,
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"서울 날씨 알려줘"</span>}]
)

<span class="kw">if</span> response.stop_reason == <span class="str">"tool_use"</span>:
    <span class="cmt"># tool_use 블록 처리</span>
    tool_use_block = next(b <span class="kw">for</span> b <span class="kw">in</span> response.content <span class="kw">if</span> b.type == <span class="str">"tool_use"</span>)
    <span class="fn">print</span>(tool_use_block.name)  <span class="cmt"># "get_weather"</span>
    <span class="fn">print</span>(tool_use_block.input)  <span class="cmt"># {"city": "서울"}</span></code></pre>
</div>

<div class="faq-item">
<h3 id="multimodal">Q10. 이미지 분석은 어떻게 하나요?</h3>
<p><strong>A:</strong> Vision API를 사용하여 이미지를 전송합니다:</p>
<pre><code><span class="kw">import</span> base64

<span class="kw">with</span> <span class="fn">open</span>(<span class="str">"image.jpg"</span>, <span class="str">"rb"</span>) <span class="kw">as</span> f:
    image_data = base64.standard_b64encode(f.read()).decode(<span class="str">"utf-8"</span>)

response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1024</span>,
    messages=[{
        <span class="str">"role"</span>: <span class="str">"user"</span>,
        <span class="str">"content"</span>: [
            {
                <span class="str">"type"</span>: <span class="str">"image"</span>,
                <span class="str">"source"</span>: {
                    <span class="str">"type"</span>: <span class="str">"base64"</span>,
                    <span class="str">"media_type"</span>: <span class="str">"image/jpeg"</span>,
                    <span class="str">"data"</span>: image_data
                }
            },
            {<span class="str">"type"</span>: <span class="str">"text"</span>, <span class="str">"text"</span>: <span class="str">"이 이미지를 설명해주세요"</span>}
        ]
    }]
)

<span class="fn">print</span>(response.content[<span class="num">0</span>].text)</code></pre>
<p><strong>지원 형식:</strong> JPEG, PNG, GIF, WebP (최대 5MB)</p>
</div>
</section>

<section>
<h2 id="troubleshooting">문제 해결</h2>

<div class="faq-item">
<h3 id="rate-limit-error">Q11. 429 Rate Limit Error가 계속 발생해요.</h3>
<p><strong>A:</strong> Rate Limit을 초과했습니다. 다음 방법으로 해결하세요:</p>

<p><strong>1. 지수 백오프 재시도 구현:</strong></p>
<pre><code><span class="kw">import</span> time
<span class="kw">import</span> random

<span class="kw">def</span> <span class="fn">call_with_retry</span>(max_retries=<span class="num">5</span>):
    <span class="kw">for</span> attempt <span class="kw">in</span> <span class="fn">range</span>(max_retries):
        <span class="kw">try</span>:
            response = client.messages.create(
                model=<span class="str">"claude-<tier>"</span>,
                max_tokens=<span class="num">1024</span>,
                messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"Hello"</span>}]
            )
            <span class="kw">return</span> response
        <span class="kw">except</span> anthropic.RateLimitError <span class="kw">as</span> e:
            <span class="kw">if</span> attempt == max_retries - <span class="num">1</span>:
                <span class="kw">raise</span>
            wait_time = (<span class="num">2</span> ** attempt) + random.uniform(<span class="num">0</span>, <span class="num">1</span>)
            time.sleep(wait_time)</code></pre>

<p><strong>2. 티어 확인 및 업그레이드:</strong></p>
<ul>
<li>Build Tier: 50 RPM, 40K TPM, 400K TPD</li>
<li>Scale Tier: 1000 RPM, 80K TPM, 2.5M TPD (구매액 증가 시 자동 상승)</li>
</ul>

<p><strong>3. 요청 분산:</strong></p>
<ul>
<li>배치 처리 시 요청 간 딜레이 추가</li>
<li>동시 요청 수 제한</li>
<li>비동기 처리 활용</li>
</ul>
</div>

<div class="faq-item">
<h3 id="slow-response">Q12. 응답이 너무 느려요.</h3>
<p><strong>A:</strong> 성능 최적화 체크리스트:</p>

<p><strong>1. 적절한 모델 선택:</strong></p>
<ul>
<li>Haiku: 가장 빠름 (~1-3초)</li>
<li>Sonnet: 중간 (~3-8초)</li>
<li>Opus: 가장 느림 (~10-20초)</li>
</ul>

<p><strong>2. max_tokens 조정:</strong></p>
<pre><code><span class="cmt"># 너무 큰 max_tokens는 응답 시간을 늘립니다</span>
response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">500</span>,  <span class="cmt"># 필요한 만큼만 설정</span>
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"간단히 답해줘"</span>}]
)</code></pre>

<p><strong>3. Prompt Caching 활용:</strong></p>
<pre><code>system_prompt = [{
    <span class="str">"type"</span>: <span class="str">"text"</span>,
    <span class="str">"text"</span>: <span class="str">"[긴 시스템 프롬프트나 문서]"</span>,
    <span class="str">"cache_control"</span>: {<span class="str">"type"</span>: <span class="str">"ephemeral"</span>}
}]</code></pre>

<p><strong>4. 컨텍스트 크기 줄이기:</strong></p>
<ul>
<li>불필요한 대화 히스토리 제거</li>
<li>긴 문서는 요약 후 전송</li>
<li>청킹 전략 사용</li>
</ul>
</div>

<div class="faq-item">
<h3 id="context-overflow">Q13. "Context length exceeded" 에러가 발생해요.</h3>
<p><strong>A:</strong> 입력 + 출력이 200K 토큰을 초과했습니다. 해결 방법:</p>

<p><strong>1. 청킹 전략:</strong></p>
<pre><code><span class="kw">def</span> <span class="fn">chunk_text</span>(text, chunk_size=<span class="num">100000</span>):
    <span class="str">"""텍스트를 청크로 분할"""</span>
    words = text.split()
    chunks = []
    <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="num">0</span>, <span class="fn">len</span>(words), chunk_size):
        chunk = <span class="str">" "</span>.join(words[i:i+chunk_size])
        chunks.append(chunk)
    <span class="kw">return</span> chunks

<span class="kw">def</span> <span class="fn">process_long_document</span>(document):
    chunks = chunk_text(document)
    results = []

    <span class="kw">for</span> chunk <span class="kw">in</span> chunks:
        response = client.messages.create(
            model=<span class="str">"claude-<tier>"</span>,
            max_tokens=<span class="num">2000</span>,
            messages=[{
                <span class="str">"role"</span>: <span class="str">"user"</span>,
                <span class="str">"content"</span>: f<span class="str">"다음 텍스트를 요약하세요:\n\n{chunk}"</span>
            }]
        )
        results.append(response.content[<span class="num">0</span>].text)

    <span class="kw">return</span> results</code></pre>

<p><strong>2. 대화 히스토리 관리:</strong></p>
<pre><code><span class="kw">def</span> <span class="fn">truncate_history</span>(messages, max_messages=<span class="num">10</span>):
    <span class="str">"""최근 N개 메시지만 유지"""</span>
    <span class="kw">return</span> messages[-max_messages:]

<span class="kw">def</span> <span class="fn">summarize_history</span>(messages):
    <span class="str">"""오래된 대화를 요약"""</span>
    <span class="kw">if</span> <span class="fn">len</span>(messages) > <span class="num">20</span>:
        old_messages = messages[:-<span class="num">10</span>]
        summary = client.messages.create(
            model=<span class="str">"claude-<tier>"</span>,
            max_tokens=<span class="num">500</span>,
            messages=[{
                <span class="str">"role"</span>: <span class="str">"user"</span>,
                <span class="str">"content"</span>: f<span class="str">"대화 요약:\n{old_messages}"</span>
            }]
        )
        <span class="kw">return</span> [{<span class="str">"role"</span>: <span class="str">"assistant"</span>, <span class="str">"content"</span>: summary.content[<span class="num">0</span>].text}] + messages[-<span class="num">10</span>:]
    <span class="kw">return</span> messages</code></pre>
</div>

<div class="faq-item">
<h3 id="inconsistent-output">Q14. 같은 프롬프트인데 응답이 매번 달라요.</h3>
<p><strong>A:</strong> Claude는 생성형 AI이므로 결정론적이지 않습니다. 일관성을 높이려면:</p>

<p><strong>1. temperature 조정:</strong></p>
<pre><code>response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1024</span>,
    temperature=<span class="num">0</span>,  <span class="cmt"># 0에 가까울수록 일관성 증가 (기본값: 1)</span>
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"2+2는?"</span>}]
)</code></pre>

<p><strong>2. 구체적인 형식 지정:</strong></p>
<pre><code>system_prompt = <span class="str">"""다음 형식으로만 답변하세요:

정답: [숫자]
설명: [한 문장]

다른 형식이나 추가 내용은 포함하지 마세요."""</span></code></pre>

<p><strong>3. Few-shot 예제 제공:</strong></p>
<pre><code>messages = [
    {<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"긍정/부정: '이 제품 정말 좋아요!'"</span>},
    {<span class="str">"role"</span>: <span class="str">"assistant"</span>, <span class="str">"content"</span>: <span class="str">"긍정"</span>},
    {<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"긍정/부정: '실망스러워요'"</span>},
    {<span class="str">"role"</span>: <span class="str">"assistant"</span>, <span class="str">"content"</span>: <span class="str">"부정"</span>},
    {<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"긍정/부정: '배송이 빨라요'"</span>}
]</code></pre>
</div>

<div class="faq-item">
<h3 id="api-key-exposed">Q15. API 키가 노출되었어요. 어떻게 해야 하나요?</h3>
<p><strong>A:</strong> 즉시 다음 조치를 취하세요:</p>
<ol>
<li><strong>키 삭제:</strong> <a href="https://console.anthropic.com" target="_blank">Anthropic Console</a>에서 해당 키 즉시 삭제</li>
<li><strong>새 키 발급:</strong> 새 API 키 생성</li>
<li><strong>사용 내역 확인:</strong> 비정상적인 사용량 체크</li>
<li><strong>노출된 코드 수정:</strong> Git history에서 키 제거
<pre><code><span class="cmt"># Git history에서 민감한 정보 제거</span>
git filter-branch --force --index-filter \
  <span class="str">"git rm --cached --ignore-unmatch config.py"</span> \
  --prune-empty --tag-name-filter cat -- --all</code></pre>
</li>
<li><strong>향후 예방:</strong>
<ul>
<li>환경 변수 사용 (<code>ANTHROPIC_API_KEY</code>)</li>
<li><code>.env</code> 파일을 <code>.gitignore</code>에 추가</li>
<li>Secret manager 사용 (AWS Secrets Manager, GitHub Secrets)</li>
<li>코드 리뷰 시 키 노출 여부 확인</li>
</ul>
</li>
</ol>
</div>
</section>

<section>
<h2 id="claude-code-faq">Claude Code 관련 질문</h2>

<div class="faq-item">
<h3 id="what-is-claude-code">Q16. Claude Code란 무엇인가요?</h3>
<p><strong>A:</strong> Claude Code는 Anthropic의 공식 CLI(Command Line Interface) 도구로, 터미널에서 Claude를 사용할 수 있게 해줍니다:</p>
<ul>
<li><strong>코드 생성 및 수정:</strong> 자연어로 코드 작성/리팩토링 요청</li>
<li><strong>파일 읽기/쓰기:</strong> 프로젝트 파일 자동 분석 및 수정</li>
<li><strong>명령어 실행:</strong> git, npm, pip 등 자동 실행</li>
<li><strong>멀티파일 편집:</strong> 여러 파일을 동시에 수정</li>
<li><strong>컨텍스트 인식:</strong> 전체 프로젝트 구조 이해</li>
</ul>
<p>설치: <code>npm install -g @anthropic-ai/claude-code</code></p>
</div>

<div class="faq-item">
<h3 id="claude-code-vs-api">Q17. Claude Code와 Claude API의 차이는?</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>Claude API:</strong> HTTP 기반 프로그래밍 인터페이스, 애플리케이션에 통합</li>
<li><strong>Claude Code:</strong> 터미널 기반 대화형 도구, 개발자가 직접 사용</li>
</ul>
<table>
<thead>
<tr>
<th>특징</th>
<th>Claude API</th>
<th>Claude Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>사용 방식</td>
<td>프로그래밍 (Python, TS)</td>
<td>터미널 명령어</td>
</tr>
<tr>
<td>대상</td>
<td>앱 개발자</td>
<td>소프트웨어 엔지니어</td>
</tr>
<tr>
<td>파일 접근</td>
<td>직접 구현 필요</td>
<td>자동 지원</td>
</tr>
<tr>
<td>명령 실행</td>
<td>별도 구현</td>
<td>자동 실행</td>
</tr>
<tr>
<td>비용</td>
<td>토큰 사용량 기반</td>
<td>토큰 사용량 기반</td>
</tr>
</tbody>
</table>
</div>

<div class="faq-item">
<h3 id="claude-code-safe">Q18. Claude Code가 내 파일을 마음대로 수정하지는 않나요?</h3>
<p><strong>A:</strong> 안전합니다. Claude Code는 다음과 같이 작동합니다:</p>
<ul>
<li><strong>명시적 권한:</strong> 파일 읽기/쓰기 전 사용자 승인 요청</li>
<li><strong>Diff 확인:</strong> 변경사항을 먼저 보여주고 승인 후 적용</li>
<li><strong>Git 통합:</strong> 변경사항은 Git으로 추적 가능</li>
<li><strong>실행 확인:</strong> 명령어 실행 전 확인 프롬프트</li>
<li><strong>읽기 전용 모드:</strong> <code>--read-only</code> 플래그로 쓰기 방지</li>
</ul>
<p><strong>권장 사항:</strong> 항상 Git을 사용하고, 중요한 변경 전에는 브랜치를 생성하세요.</p>
</div>

<div class="faq-item">
<h3 id="claude-code-features">Q19. Claude Code로 무엇을 할 수 있나요?</h3>
<p><strong>A:</strong> 다양한 개발 작업을 자동화할 수 있습니다:</p>

<p><strong>코드 작성 및 수정:</strong></p>
<pre><code>$ claude "Python으로 FastAPI 서버 만들어줘"
$ claude "이 함수를 TypeScript로 변환해줘"
$ claude "main.py의 버그 찾아서 고쳐줘"</code></pre>

<p><strong>리팩토링:</strong></p>
<pre><code>$ claude "utils.py를 여러 모듈로 분리해줘"
$ claude "이 코드에 타입 힌트 추가해줘"</code></pre>

<p><strong>테스트 작성:</strong></p>
<pre><code>$ claude "auth.py에 대한 pytest 테스트 작성해줘"
$ claude "커버리지 90% 이상 달성하도록 테스트 추가해줘"</code></pre>

<p><strong>문서화:</strong></p>
<pre><code>$ claude "모든 함수에 docstring 추가해줘"
$ claude "README.md 작성해줘"</code></pre>

<p><strong>Git 작업:</strong></p>
<pre><code>$ claude "변경사항 커밋하고 의미있는 커밋 메시지 작성해줘"
$ claude "main 브랜치와 충돌 해결해줘"</code></pre>
</div>

<div class="faq-item">
<h3 id="claude-code-limits">Q20. Claude Code의 한계는 무엇인가요?</h3>
<p><strong>A:</strong> 다음과 같은 제약이 있습니다:</p>
<ul>
<li><strong>컨텍스트 제한:</strong> 매우 큰 프로젝트(수천 개 파일)는 처리가 어려울 수 있음</li>
<li><strong>복잡한 리팩토링:</strong> 전체 아키텍처 변경은 사람의 감독이 필요</li>
<li><strong>도메인 지식:</strong> 특정 비즈니스 로직은 명확한 설명이 필요</li>
<li><strong>실시간 협업:</strong> 여러 개발자가 동시에 같은 파일 수정 시 충돌 가능</li>
<li><strong>디버깅:</strong> 런타임 버그는 실행 환경 정보가 필요</li>
</ul>
<p><strong>권장:</strong> Claude Code는 보조 도구로 사용하고, 중요한 결정은 직접 검토하세요.</p>
</div>
</section>

<section>
<h2 id="vibe-coding">Vibe Coding</h2>

<div class="faq-item">
<h3 id="what-is-vibe-coding">Q21. Vibe Coding이란 무엇인가요?</h3>
<p><strong>A:</strong> Vibe Coding은 자연어 대화로 코드를 작성하는 새로운 개발 패러다임입니다:</p>
<ul>
<li><strong>정의:</strong> 세부 구문이나 API를 암기하지 않고 "의도"만 전달하면 AI가 완전한 코드를 생성</li>
<li><strong>배경:</strong> Anthropic이 Claude Opus (고성능) 출시와 함께 공식적으로 강조한 개념</li>
<li><strong>핵심 특징:</strong> 낮은 진입장벽, 빠른 프로토타이핑, 맥락 이해, 반복 개선</li>
<li><strong>지원 언어:</strong> Python, TypeScript, JavaScript, Rust, Go 등 모든 주요 프로그래밍 언어</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code><span class="cmt"># 전통적 코딩</span>
1. Stack Overflow 검색 → API 문서 읽기 → 구문 학습 → 코드 작성 → 디버깅

<span class="cmt"># Vibe Coding</span>
You: "FastAPI로 JWT 인증 시스템 만들어줘"
Claude: [완전한 코드 생성 + 설명]
You: "이제 리프레시 토큰 기능 추가해줘"
Claude: [기존 코드 개선]</code></pre>
<p>자세한 내용은 <a href="vibe-coding-patterns.html">Vibe Coding 가이드</a>를 참조하세요.</p>
</div>

<div class="faq-item">
<h3 id="vibe-coding-vs-prompting">Q22. Vibe Coding과 일반 프롬프팅의 차이는?</h3>
<p><strong>A:</strong> Vibe Coding은 프롬프팅을 넘어 전체 개발 워크플로우를 포함합니다:</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>일반 프롬프팅</th>
<th>Vibe Coding</th>
</tr>
</thead>
<tbody>
<tr>
<td>목적</td>
<td>단일 작업 (함수 생성 등)</td>
<td>전체 개발 워크플로우</td>
</tr>
<tr>
<td>스코프</td>
<td>코드 스니펫</td>
<td>프로젝트 전체 (멀티파일)</td>
</tr>
<tr>
<td>컨텍스트</td>
<td>프롬프트 내용만</td>
<td>전체 코드베이스 이해</td>
</tr>
<tr>
<td>반복 개선</td>
<td>수동으로 재요청</td>
<td>대화로 자연스럽게 개선</td>
</tr>
<tr>
<td>도구</td>
<td>웹 인터페이스, API</td>
<td>Claude Code CLI (권장)</td>
</tr>
<tr>
<td>학습 곡선</td>
<td>프롬프트 작성법 학습</td>
<td>자연어 대화만으로 충분</td>
</tr>
</tbody>
</table>
<p><strong>핵심 차이:</strong> 일반 프롬프팅은 "코드 조각 요청"이고, Vibe Coding은 "AI와 협업하는 개발 방식"입니다.</p>
</div>

<div class="faq-item">
<h3 id="vibe-coding-tips">Q23. Vibe Coding 사용 시 주의사항은?</h3>
<p><strong>A:</strong> 효과적인 Vibe Coding을 위한 권장 사항:</p>

<p><strong>✅ DO (권장 사항):</strong></p>
<ul>
<li><strong>구체적인 의도 전달:</strong> "사용자 인증" 대신 "JWT 기반 사용자 인증, 로그인/로그아웃 엔드포인트 포함"</li>
<li><strong>맥락 제공:</strong> 프로젝트 구조, 기존 코딩 스타일, 사용 중인 프레임워크 언급</li>
<li><strong>점진적 개선:</strong> 작은 기능부터 시작해서 대화로 확장</li>
<li><strong>코드 리뷰:</strong> 생성된 코드를 항상 검토하고 이해하기</li>
<li><strong>Git 사용:</strong> 변경사항 추적 및 롤백 가능하도록 버전 관리</li>
</ul>

<p><strong>❌ DON'T (피해야 할 것):</strong></p>
<ul>
<li><strong>맹목적 신뢰:</strong> 생성된 코드를 검증 없이 프로덕션에 배포</li>
<li><strong>모호한 요청:</strong> "좋은 코드 만들어줘" 같은 불명확한 지시</li>
<li><strong>보안 무시:</strong> API 키, 비밀번호 등 민감 정보를 프롬프트에 포함</li>
<li><strong>복잡한 전체 시스템:</strong> 한 번에 대규모 아키텍처 변경 요청 (단계별로 진행)</li>
<li><strong>디버깅 위임:</strong> 에러 메시지만 전달하고 컨텍스트 생략</li>
</ul>

<p><strong>예시 (좋은 Vibe Coding 요청):</strong></p>
<pre><code>"현재 Express.js 프로젝트에 Redis 캐싱 레이어를 추가하고 싶어.
- 모든 GET 요청은 5분간 캐싱
- POST/PUT/DELETE는 관련 캐시 무효화
- 환경 변수로 Redis 연결 설정
- 기존 코드 스타일(TypeScript, async/await) 유지"</code></pre>
</div>

<div class="faq-item">
<h3 id="codex-what-is">Q24. Codex는 어떤 도구인가요?</h3>
<p><strong>A:</strong> Codex는 코딩 작업을 실행하고 변경 사항을 제안하는 코딩 에이전트입니다.</p>
<ul>
<li><strong>작업 범위 지정:</strong> 수정할 파일/폴더와 목표를 명확히 지정할수록 품질이 높습니다.</li>
<li><strong>검증 흐름:</strong> 테스트 실행과 결과 확인을 함께 요청하는 것이 안전합니다.</li>
<li><strong>보안:</strong> 민감한 작업은 승인 흐름과 권한 제한을 적용하세요.</li>
</ul>
<p>자세한 내용은 <a href="codex.html">Codex 가이드</a>를 참조하세요.</p>
</div>
</section>

<section>
<h2 id="best-practices">모범 사례</h2>

<div class="faq-item">
<h3 id="prompt-tips">Q25. 더 나은 응답을 받으려면 어떻게 프롬프트를 작성해야 하나요?</h3>
<p><strong>A:</strong> 효과적인 프롬프트 작성 팁:</p>

<p><strong>1. 구체적으로 작성:</strong></p>
<pre><code><span class="cmt"># 나쁜 예</span>
"코드 작성해줘"

<span class="cmt"># 좋은 예</span>
"Python FastAPI로 사용자 인증 API를 작성해줘.
JWT 토큰 사용, 로그인/로그아웃 엔드포인트 포함,
SQLAlchemy로 PostgreSQL 연결"</code></pre>

<p><strong>2. 형식 지정:</strong></p>
<pre><code>"다음 형식으로 답변해줘:
1. 요약 (3줄 이내)
2. 상세 설명
3. 코드 예제
4. 주의사항"</code></pre>

<p><strong>3. 컨텍스트 제공:</strong></p>
<pre><code>"Django REST Framework 프로젝트에서 사용자 모델을 확장하려고 합니다.
현재 AbstractUser를 상속받고 있고, 프로필 이미지와 생일 필드를 추가하고 싶습니다."</code></pre>

<p><strong>4. 단계별 요청:</strong></p>
<pre><code>"다음 순서로 작업해줘:
1. 먼저 requirements.txt 확인
2. 필요한 패키지 설치 명령어 제시
3. 코드 작성
4. 테스트 코드 작성"</code></pre>

<p><strong>5. 제약사항 명시:</strong></p>
<pre><code>"Python 3.8 호환, 외부 라이브러리 사용 금지,
타입 힌트 필수, 최대 100줄 이내"</code></pre>
</div>

<div class="faq-item">
<h3 id="cost-optimization">Q26. 비용을 절감하려면 어떻게 해야 하나요?</h3>
<p><strong>A:</strong> 종합 비용 최적화 전략:</p>

<p><strong>1. 적절한 모델 선택:</strong></p>
<pre><code><span class="cmt"># 간단한 작업 → Haiku</span>
response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"감정 분석: 좋아요"</span>}]
)

<span class="cmt"># 복잡한 작업 → Sonnet/Opus</span>
response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"복잡한 비즈니스 로직 분석"</span>}]
)</code></pre>

<p><strong>2. max_tokens 최적화:</strong></p>
<pre><code><span class="cmt"># 필요한 만큼만 요청</span>
response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">100</span>,  <span class="cmt"># 짧은 답변만 필요한 경우</span>
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: <span class="str">"YES 또는 NO로만 답해줘"</span>}]
)</code></pre>

<p><strong>3. Prompt Caching 활용:</strong></p>
<pre><code><span class="cmt"># 동일한 시스템 프롬프트/문서를 반복 사용 시</span>
system = [{
    <span class="str">"type"</span>: <span class="str">"text"</span>,
    <span class="str">"text"</span>: large_document,
    <span class="str">"cache_control"</span>: {<span class="str">"type"</span>: <span class="str">"ephemeral"</span>}
}]

<span class="cmt"># 첫 요청: 캐시 쓰기 비용</span>
<span class="cmt"># 이후 요청: 90% 비용 절감</span></code></pre>

<p><strong>4. 컨텍스트 압축:</strong></p>
<pre><code><span class="kw">def</span> <span class="fn">compress_context</span>(messages):
    <span class="cmt"># 오래된 메시지 요약</span>
    <span class="kw">if</span> <span class="fn">len</span>(messages) > <span class="num">10</span>:
        old = messages[:-<span class="num">5</span>]
        summary = summarize(old)  <span class="cmt"># Haiku 사용</span>
        <span class="kw">return</span> [summary] + messages[-<span class="num">5</span>:]
    <span class="kw">return</span> messages</code></pre>

<p><strong>5. 배치 처리:</strong></p>
<pre><code><span class="cmt"># 여러 질문을 한 번에</span>
questions = [<span class="str">"질문1"</span>, <span class="str">"질문2"</span>, <span class="str">"질문3"</span>]
combined = <span class="str">"\n\n"</span>.join(f<span class="str">"{i+1}. {q}"</span> <span class="kw">for</span> i, q <span class="kw">in</span> <span class="fn">enumerate</span>(questions))

response = client.messages.create(
    model=<span class="str">"claude-<tier>"</span>,
    max_tokens=<span class="num">1000</span>,
    messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: combined}]
)</code></pre>
</div>

<div class="faq-item">
<h3 id="production-tips">Q27. 프로덕션 환경에서 주의할 점은?</h3>
<p><strong>A:</strong> 프로덕션 배포 체크리스트:</p>

<p><strong>1. 에러 핸들링:</strong></p>
<pre><code><span class="kw">import</span> anthropic
<span class="kw">import</span> logging

logger = logging.getLogger(__name__)

<span class="kw">try</span>:
    response = client.messages.create(...)
<span class="kw">except</span> anthropic.RateLimitError <span class="kw">as</span> e:
    logger.error(<span class="str">f"Rate limit: {e}"</span>)
    <span class="cmt"># 재시도 로직</span>
<span class="kw">except</span> anthropic.APIError <span class="kw">as</span> e:
    logger.error(<span class="str">f"API error: {e}"</span>)
    <span class="cmt"># 사용자에게 친절한 메시지</span>
<span class="kw">except</span> <span class="type">Exception</span> <span class="kw">as</span> e:
    logger.critical(<span class="str">f"Unexpected error: {e}"</span>)
    <span class="cmt"># 알림 전송</span></code></pre>

<p><strong>2. 타임아웃 설정:</strong></p>
<pre><code>client = anthropic.Anthropic(
    api_key=os.environ[<span class="str">"ANTHROPIC_API_KEY"</span>],
    timeout=<span class="num">30.0</span>,  <span class="cmt"># 30초 타임아웃</span>
    max_retries=<span class="num">3</span>
)</code></pre>

<p><strong>3. 모니터링:</strong></p>
<ul>
<li>응답 시간 추적</li>
<li>토큰 사용량 모니터링</li>
<li>에러율 측정</li>
<li>비용 추적</li>
</ul>

<p><strong>4. 보안:</strong></p>
<ul>
<li>API 키를 환경 변수나 Secret Manager에 저장</li>
<li>사용자 입력 검증 (프롬프트 인젝션 방지)</li>
<li>출력 필터링 (민감 정보 노출 방지)</li>
<li>Rate limiting 구현</li>
</ul>

<p><strong>5. 캐싱 및 최적화:</strong></p>
<pre><code><span class="kw">from</span> functools <span class="kw">import</span> lru_cache

<span class="cmt"># 동일 질문에 대한 캐싱</span>
@lru_cache(maxsize=<span class="num">100</span>)
<span class="kw">def</span> <span class="fn">get_cached_response</span>(prompt: <span class="type">str</span>):
    response = client.messages.create(
        model=<span class="str">"claude-<tier>"</span>,
        max_tokens=<span class="num">1024</span>,
        messages=[{<span class="str">"role"</span>: <span class="str">"user"</span>, <span class="str">"content"</span>: prompt}]
    )
    <span class="kw">return</span> response.content[<span class="num">0</span>].text</code></pre>
</div>
</section>

<section>
<h2 id="more-help">추가 도움말</h2>

<p>더 많은 정보가 필요하시면 다음 리소스를 참고하세요:</p>

<ul>
<li><strong>공식 문서:</strong> <a href="https://docs.anthropic.com" target="_blank">docs.anthropic.com</a></li>
<li><strong>API 레퍼런스:</strong> <a href="https://docs.anthropic.com/en/api" target="_blank">API Reference</a></li>
<li><strong>Discord 커뮤니티:</strong> <a href="https://discord.gg/anthropic" target="_blank">Anthropic Discord</a></li>
<li><strong>GitHub:</strong> <a href="https://github.com/anthropics" target="_blank">github.com/anthropics</a></li>
<li><strong>지원팀:</strong> <a href="mailto:support@anthropic.com">support@anthropic.com</a></li>
</ul>

<p>이 FAQ에 없는 질문이 있으시면 <a href="https://github.com/anthropics/anthropic-sdk-python/issues" target="_blank">GitHub Issues</a>에 문의해주세요.</p>
</section>

<section class="content-section">
  <h2 id="summary">핵심 정리</h2>
  <ul>
    <li>자주 묻는 질문 (FAQ)의 핵심 개념과 흐름을 정리합니다.</li>
    <li>일반적인 질문를 단계별로 이해합니다.</li>
    <li>실전 적용 시 기준과 주의점을 확인합니다.</li>
  </ul>
</section>

<section class="content-section">
  <h2 id="practice-tips">실무 팁</h2>
  <ul>
    <li>입력/출력 예시를 고정해 재현성을 확보하세요.</li>
    <li>자주 묻는 질문 (FAQ) 범위를 작게 잡고 단계적으로 확장하세요.</li>
    <li>일반적인 질문 조건을 문서화해 대응 시간을 줄이세요.</li>
  </ul>
</section>
<nav class="page-nav"></nav>
</article>
</main>

<aside class="inline-toc">
  <div class="toc-title">목차</div>
  <div class="toc-nav"></div>
</aside>
<footer class="site-footer"></footer>
</div>

<script src="../js/main.js"></script>
</body>
</html>
