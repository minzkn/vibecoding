<!DOCTYPE html>
<html lang="ko" data-theme="dark-kernel">
<head>
<!-- BEGIN: Google adsense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2110881342960271" crossorigin="anonymous"></script>
<!-- END: Google adsense -->
<!-- BEGIN: Google adsense repair -->
<script async src="https://fundingchoicesmessages.google.com/i/pub-2110881342960271?ers=1" nonce="laI6FT8gpRxugDJv5AGJRA"></script><script nonce="laI6FT8gpRxugDJv5AGJRA">(function() {function signalGooglefcPresent() {if (!window.frames['googlefcPresent']) {if (document.body) {const iframe = document.createElement('iframe'); iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;'; iframe.style.display = 'none'; iframe.name = 'googlefcPresent'; document.body.appendChild(iframe);} else {setTimeout(signalGooglefcPresent, 0);}}}signalGooglefcPresent();})();</script>
<!-- END: Google adsense repair -->
<!-- BEGIN: Google analytics -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1VWQF060SX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1VWQF060SX');
</script>
<!-- END: Google analytics -->

<script>
(function(){var m=document.cookie.match(/claude_theme=([^;]+)/);if(m)document.documentElement.setAttribute('data-theme',m[1]);})();
</script>
<meta charset="UTF-8">
<meta property="og:type" content="article">
<meta property="og:site_name" content="AI Vibe Coding 가이드 /with MINZKN">
<meta property="og:title" content="Vibe Coding 패턴">
<meta property="og:description" content="Vibe Coding 패턴: Claude를 활용한 실전 코딩 워크플로우와 검증된 패턴들을 소개합니다. TDD, 리팩토링, 디버깅부터 프로젝트 시작, 코드 리뷰, 문서화까지 실무에서 바로 사용할 수 있는 15가지 실전 사례와 안티패턴 회피 전략을 제공합니다.">
<meta property="og:url" content="https://minzkn.com/claude/pages/vibe-coding-patterns.html">
<meta property="og:image" content="https://minzkn.com/claude/images/og-image.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Vibe Coding 패턴: Claude를 활용한 실전 코딩 워크플로우와 검증된 패턴들을 소개합니다. TDD, 리팩토링, 디버깅부터 프로젝트 시작, 코드 리뷰, 문서화까지 실무에서 바로 사용할 수 있는 15가지 실전 사례와 안티패턴 회피 전략을 제공합니다.">
<meta name="keywords" content="Claude, AI, LLM, Vibe Coding 패턴, Vibe Coding이란?, 디자인 패턴, 실전 워크플로우, 프로젝트 시작 패턴">
<meta name="author" content="MINZKN">
<title>Vibe Coding 패턴 - AI Vibe Coding 가이드 /with MINZKN</title>
<link rel="icon" type="image/svg+xml" href="../images/favicon.svg">
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css">
<link rel="stylesheet" href="../css/themes.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/responsive.css">
</head>
<body>
<div class="page-wrapper">

<header class="site-header"></header>
<nav class="side-nav" aria-label="사이트 내비게이션"></nav>

<main class="main-content">

<div class="breadcrumb"></div>

<section class="content-section">
  <h1 id="top">Vibe Coding 패턴</h1>
  <p class="lead">
    Claude를 활용한 실전 코딩 워크플로우와 검증된 패턴들을 소개합니다.
    TDD, 리팩토링, 디버깅부터 프로젝트 시작, 코드 리뷰, 문서화까지 실무에서 바로 사용할 수 있는 15가지 실전 사례와 안티패턴 회피 전략을 제공합니다.
  </p>

<div class="info-box warning">
  <strong>업데이트 안내:</strong> 모델/요금/버전/정책 등 시점에 민감한 정보는 변동될 수 있습니다.
  최신 내용은 공식 문서를 확인하세요.
</div>
</section>

<section class="content-section">
  <h2 id="what-is-vibe-coding">Vibe Coding이란?</h2>

  <div class="info-box tip">
    <div class="info-box-title">핵심 개념</div>
    <p>
      <strong>Vibe Coding</strong>은 AI와 협업하여 코드를 작성하는 새로운 패러다임입니다.
      전통적인 코딩이 "어떻게(How)"에 집중했다면, Vibe Coding은 "무엇을(What)" 만들지에 집중합니다.
    </p>
    <ul>
      <li><strong>의도 중심</strong>: 구현 세부사항보다 목적과 요구사항을 명확히</li>
      <li><strong>반복적 개선</strong>: 초안 → 피드백 → 개선의 빠른 사이클</li>
      <li><strong>협업적 사고</strong>: AI를 페어 프로그래머처럼 활용</li>
      <li><strong>컨텍스트 공유</strong>: 프로젝트 맥락을 AI와 효과적으로 공유</li>
    </ul>
  </div>

  <h3 id="vibe-vs-traditional">전통적 코딩 vs Vibe Coding</h3>

  <table class="comparison-table">
    <thead>
      <tr>
        <th style="width:50%">전통적 코딩</th>
        <th style="width:50%">Vibe Coding</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <strong>1. 요구사항 분석</strong><br>
          개발자가 모든 세부사항 파악
        </td>
        <td>
          <strong>1. 의도 명세</strong><br>
          핵심 목표와 제약사항만 명시
        </td>
      </tr>
      <tr>
        <td>
          <strong>2. 설계</strong><br>
          아키텍처, 자료구조, 알고리즘 직접 설계
        </td>
        <td>
          <strong>2. AI와 협업 설계</strong><br>
          "이런 기능이 필요해" → AI가 옵션 제시
        </td>
      </tr>
      <tr>
        <td>
          <strong>3. 구현</strong><br>
          라인 바이 라인으로 코드 작성
        </td>
        <td>
          <strong>3. 생성 & 리뷰</strong><br>
          AI가 초안 생성 → 개발자가 리뷰 & 피드백
        </td>
      </tr>
      <tr>
        <td>
          <strong>4. 테스트</strong><br>
          테스트 코드 수동 작성
        </td>
        <td>
          <strong>4. 자동 테스트 생성</strong><br>
          "이 함수를 테스트해줘" → 즉시 테스트 코드
        </td>
      </tr>
      <tr>
        <td>
          <strong>5. 디버깅</strong><br>
          스택 트레이스 분석, 단계별 디버깅
        </td>
        <td>
          <strong>5. AI 지원 디버깅</strong><br>
          에러 메시지 + 코드 → AI가 원인 파악 & 수정안 제시
        </td>
      </tr>
    </tbody>
  </table>

  <h3 id="vibe-principles">핵심 원칙</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">Vibe Coding 5원칙</span>
    </div>
    <pre><code><span class="cmt"># 1. Start with Intent (의도로 시작)</span>
"무엇을"을 먼저, "어떻게"는 나중에
예: "사용자 인증이 필요해" → 구현은 AI와 협의

<span class="cmt"># 2. Iterate Quickly (빠른 반복)</span>
완벽한 첫 시도보다 빠른 프로토타입 → 개선
예: 70% 완성도로 먼저 보고 피드백

<span class="cmt"># 3. Context is King (컨텍스트가 왕)</span>
프로젝트 상황, 기술 스택, 제약사항 명확히
예: "Next.js 14, TypeScript, Prisma 사용 중"

<span class="cmt"># 4. Test First, Fix Fast (테스트 우선, 빠른 수정)</span>
테스트를 먼저 생성하고 실패 시 즉시 수정
예: "테스트 작성 → 실패 → 코드 수정"

<span class="cmt"># 5. Document as You Go (진행하며 문서화)</span>
코드 작성 중 문서도 함께 생성
예: "이 API를 문서화해줘"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="design-patterns">디자인 패턴</h2>

  <h3 id="pattern-incremental">패턴 1: 점진적 구축 (Incremental Build)</h3>

  <p>복잡한 기능을 한 번에 만들지 말고 작은 단위로 쪼개서 구축합니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">프롬프트 시퀀스</span>
    </div>
    <pre><code><span class="cmt"># Step 1: 기본 골격</span>
"FastAPI로 사용자 관리 API의 기본 골격을 만들어주세요.
- User 모델 (Pydantic)
- CRUD 엔드포인트 (함수 시그니처만)
- 라우터 설정"

<span class="cmt"># Step 2: CREATE 구현</span>
"이제 POST /users 엔드포인트를 완성해주세요.
- 입력 검증 (이메일, 비밀번호 강도)
- bcrypt로 비밀번호 해싱
- PostgreSQL 저장
- 성공 시 201 응답"

<span class="cmt"># Step 3: READ 구현</span>
"GET /users와 GET /users/{id}를 구현해주세요.
- 페이지네이션 (limit, offset)
- 비밀번호는 응답에서 제외
- 존재하지 않는 ID는 404"

<span class="cmt"># Step 4: 인증 추가</span>
"JWT 인증을 추가해주세요.
- 로그인 엔드포인트 (POST /auth/login)
- 토큰 검증 미들웨어
- 보호된 엔드포인트에 적용"

<span class="cmt"># Step 5: 테스트</span>
"모든 엔드포인트에 대한 pytest 테스트를 작성해주세요."</code></pre>
  </div>

  <div class="info-box tip">
    <div class="info-box-title">왜 효과적인가?</div>
    <ul>
      <li>각 단계가 간단하여 AI가 정확한 코드 생성</li>
      <li>중간에 문제 발견 시 빠른 수정 가능</li>
      <li>점진적으로 복잡도 증가 → 학습 곡선 완만</li>
      <li>각 단계별로 테스트 가능</li>
    </ul>
  </div>

  <h3 id="pattern-tdd">패턴 2: AI 주도 TDD (AI-Driven TDD)</h3>

  <p>테스트를 먼저 작성하고, 테스트를 통과하는 코드를 생성합니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">TDD 워크플로우</span>
    </div>
    <pre><code><span class="cmt"># Red: 실패하는 테스트 작성</span>
<span class="str">프롬프트:</span> "이메일 유효성 검증 함수에 대한 pytest 테스트를 작성해주세요.

테스트 케이스:
- 유효한 이메일: user@example.com ✅
- 로컬 파트 없음: @example.com ❌
- 도메인 없음: user@ ❌
- 공백 포함: user @example.com ❌
- 다중 @ 기호: user@@example.com ❌"

<span class="cmt"># Green: 테스트를 통과하는 최소 코드</span>
<span class="str">프롬프트:</span> "위 테스트를 통과하는 validate_email 함수를 작성해주세요.
정규식 사용, 타입 힌트 포함."

<span class="cmt"># Refactor: 코드 개선</span>
<span class="str">프롬프트:</span> "이 함수를 다음과 같이 개선해주세요:
1. 더 정확한 RFC 5322 정규식 사용
2. 상세한 에러 메시지 (어떤 부분이 잘못되었는지)
3. docstring 추가
4. 성능 최적화 (정규식 컴파일)"</code></pre>
  </div>

  <h3 id="pattern-rubber-duck">패턴 3: 러버덕 디버깅 (Rubber Duck Debugging)</h3>

  <p>문제를 AI에게 설명하는 과정에서 스스로 해결책을 찾습니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">러버덕 프롬프트</span>
    </div>
    <pre><code>"다음 코드에서 메모리 누수가 발생합니다. 단계별로 분석하겠습니다.

<span class="cmt"># 1. 증상</span>
- 프로그램 실행 시간이 길어질수록 메모리 사용량 증가
- 30분 후 500MB → 2GB
- 특정 작업 후 메모리가 해제되지 않음

<span class="cmt"># 2. 문제 코드</span>
[코드 첨부]

<span class="cmt"># 3. 의심되는 부분</span>
- 이벤트 리스너를 제거하지 않고 계속 추가
- 클로저가 외부 변수를 참조하여 GC 방지
- 캐시를 무한정 저장

<span class="cmt"># 4. 질문</span>
1. 어떤 부분이 메모리 누수의 원인인가요?
2. 어떻게 수정해야 하나요?
3. 메모리 누수를 방지하는 패턴은?"</code></pre>
  </div>

  <div class="info-box info">
    <div class="info-box-title">러버덕 효과</div>
    <p>
      문제를 구조화하여 설명하는 과정에서 원인을 발견하는 경우가 많습니다.
      AI는 설명을 듣고 추가 인사이트를 제공하거나, 놓친 부분을 지적합니다.
    </p>
  </div>

  <h3 id="pattern-context-builder">패턴 4: 컨텍스트 빌더 (Context Builder)</h3>

  <p>프로젝트 컨텍스트를 체계적으로 구축하여 AI가 정확한 코드를 생성하도록 합니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">컨텍스트 템플릿</span>
    </div>
    <pre><code><span class="cmt"># 프로젝트 컨텍스트</span>

<span class="cmt">## 1. 프로젝트 개요</span>
- 이름: 전자상거래 플랫폼
- 목적: 중소 쇼핑몰을 위한 SaaS
- 사용자: 월 1만 명, 피크 시 동시 접속 500명

<span class="cmt">## 2. 기술 스택</span>
- Backend: FastAPI 0.104, Python 3.11
- Database: PostgreSQL 15, Redis 7
- Frontend: Next.js 14, TypeScript 5.3
- Deploy: Docker, Kubernetes, AWS

<span class="cmt">## 3. 현재 구조</span>
```
app/
  api/
    routes/
      users.py
      products.py
    dependencies/
      auth.py
  models/
  schemas/
  services/
```

<span class="cmt">## 4. 코딩 규칙</span>
- 함수명: snake_case
- 클래스명: PascalCase
- 타입 힌트 필수
- Docstring: Google 스타일
- 최대 줄 길이: 100자

<span class="cmt">## 5. 현재 작업</span>
장바구니 기능 추가 중
- [ ] Cart 모델 정의
- [ ] 장바구니 추가/삭제 API
- [ ] 재고 확인 로직
- [ ] 테스트 작성

<span class="cmt">## 요청</span>
Cart 모델과 CRUD API를 작성해주세요.</code></pre>
  </div>

  <h3 id="pattern-spec-driven">패턴 5: 스펙 주도 개발 (Spec-Driven Development)</h3>

  <p>OpenAPI, TypeScript 인터페이스 등 스펙을 먼저 정의하고 구현합니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">스펙 우선 프롬프트</span>
    </div>
    <pre><code><span class="cmt"># Step 1: 스펙 정의</span>
"다음 요구사항에 맞는 OpenAPI 3.0 스펙을 작성해주세요:

<span class="cmt">## 엔드포인트</span>
POST /api/orders - 주문 생성
GET /api/orders - 주문 목록
GET /api/orders/{id} - 주문 상세
PATCH /api/orders/{id} - 주문 상태 변경

<span class="cmt">## 데이터 모델</span>
Order:
  - id: string (UUID)
  - user_id: string
  - items: OrderItem[]
  - total: number
  - status: 'pending' | 'paid' | 'shipped' | 'completed'
  - created_at: datetime"

<span class="cmt"># Step 2: 스펙에서 코드 생성</span>
"위 OpenAPI 스펙을 기반으로 FastAPI 코드를 생성해주세요:
1. Pydantic 모델
2. 라우터 (함수 시그니처 + docstring)
3. 응답 예시"

<span class="cmt"># Step 3: 구현</span>
"각 엔드포인트의 비즈니스 로직을 구현해주세요."</code></pre>
  </div>

  <h3 id="pattern-example-driven">패턴 6: 예제 주도 (Example-Driven)</h3>

  <p>실제 사용 예제를 먼저 작성하고, 그에 맞는 API를 설계합니다.</p>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">예제 우선 프롬프트</span>
    </div>
    <pre><code>"다음과 같이 사용할 수 있는 데이터 검증 라이브러리를 만들어주세요.

<span class="cmt"># 사용 예제</span>
<span class="kw">const</span> schema = {
  name: [required(), minLength(<span class="num">2</span>), maxLength(<span class="num">50</span>)],
  email: [required(), email()],
  age: [required(), number(), min(<span class="num">18</span>), max(<span class="num">120</span>)],
  password: [
    required(),
    minLength(<span class="num">8</span>),
    pattern(<span class="str">/^(?=.*[A-Z])(?=.*[0-9])/</span>, <span class="str">'대문자와 숫자 포함'</span>)
  ]
};

<span class="kw">const</span> validator = <span class="fn">createValidator</span>(schema);
<span class="kw">const</span> result = validator.<span class="fn">validate</span>(userData);

<span class="kw">if</span> (!result.valid) {
  console.<span class="fn">log</span>(result.errors);
  <span class="cmt">// { email: ['유효한 이메일 형식이 아닙니다'], age: ['18 이상이어야 합니다'] }</span>
}

<span class="cmt"># 요구사항</span>
1. TypeScript로 작성
2. 체이닝 가능한 밸리데이터
3. 커스텀 밸리데이터 지원
4. 상세한 에러 메시지
5. 비동기 검증 지원 (예: 이메일 중복 확인)"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="workflows">실전 워크플로우</h2>

  <h3 id="workflow-new-feature">워크플로우 1: 새로운 기능 추가</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">7단계 프로세스</span>
    </div>
    <pre><code><span class="cmt">## 1. 요구사항 정리</span>
<span class="str">프롬프트:</span> "다음 기능의 요구사항을 정리해주세요:
- 소셜 로그인 (Google, GitHub)
- 기존 이메일 로그인과 통합
- 프로필 자동 생성"

<span class="cmt">## 2. 설계 리뷰</span>
<span class="str">프롬프트:</span> "OAuth 2.0 흐름을 설명하고, 다음을 포함한 설계안을 제시해주세요:
- 데이터베이스 스키마 (User, SocialAccount 테이블)
- API 엔드포인트
- 보안 고려사항"

<span class="cmt">## 3. 모델 정의</span>
<span class="str">프롬프트:</span> "SQLAlchemy로 User와 SocialAccount 모델을 작성해주세요.
- User: 기존 모델 확장
- SocialAccount: provider, provider_id, access_token 등"

<span class="cmt">## 4. API 구현</span>
<span class="str">프롬프트:</span> "FastAPI로 OAuth 콜백 엔드포인트를 구현해주세요:
GET /auth/google/callback
- 인증 코드 → 액세스 토큰 교환
- 사용자 정보 조회
- 신규 사용자는 자동 생성, 기존 사용자는 연동"

<span class="cmt">## 5. 프론트엔드 연동</span>
<span class="str">프롬프트:</span> "Next.js에서 Google 로그인 버튼을 구현해주세요.
- next-auth 사용
- 세션 관리
- 로그인 상태에 따른 UI 변경"

<span class="cmt">## 6. 테스트</span>
<span class="str">프롬프트:</span> "OAuth 콜백 엔드포인트에 대한 테스트를 작성해주세요:
- 성공 케이스: 신규 사용자, 기존 사용자
- 실패 케이스: 잘못된 코드, 만료된 토큰
- httpx_mock 사용"

<span class="cmt">## 7. 문서화</span>
<span class="str">프롬프트:</span> "소셜 로그인 사용 가이드를 Markdown으로 작성해주세요:
- 사용자 가이드
- 개발자 가이드 (환경 변수 설정)
- 트러블슈팅"</code></pre>
  </div>

  <h3 id="workflow-refactoring">워크플로우 2: 레거시 코드 리팩토링</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">안전한 리팩토링 프로세스</span>
    </div>
    <pre><code><span class="cmt">## 1. 이해하기</span>
<span class="str">프롬프트:</span> "다음 레거시 코드의 동작을 설명해주세요:

[레거시 코드 500줄]

다음을 포함:
1. 전체 흐름
2. 각 함수의 역할
3. 의존성 관계
4. 숨겨진 가정(assumptions)"

<span class="cmt">## 2. 테스트 작성 (보호망)</span>
<span class="str">프롬프트:</span> "기존 동작을 보장하는 테스트를 작성해주세요:
- 모든 공개 함수에 대한 테스트
- 엣지 케이스 포함
- 100% 브랜치 커버리지 목표"

<span class="cmt">## 3. 문제점 파악</span>
<span class="str">프롬프트:</span> "이 코드의 문제점을 분석해주세요:
- 코드 스멜 (긴 함수, 중복 코드 등)
- 성능 이슈
- 보안 취약점
- 유지보수성 문제"

<span class="cmt">## 4. 리팩토링 계획</span>
<span class="str">프롬프트:</span> "단계별 리팩토링 계획을 수립해주세요:
- 각 단계마다 테스트 통과 보장
- 리스크가 낮은 것부터 시작
- 각 단계의 예상 시간"

<span class="cmt">## 5. 점진적 리팩토링</span>
<span class="str">프롬프트 1:</span> "먼저 함수명을 의미 있게 변경해주세요. 테스트는 그대로 통과해야 합니다."
<span class="str">프롬프트 2:</span> "긴 함수를 작은 함수로 분해해주세요."
<span class="str">프롬프트 3:</span> "중복 코드를 제거하고 공통 함수로 추출해주세요."
<span class="str">프롬프트 4:</span> "성능을 개선해주세요 (알고리즘 최적화)."

<span class="cmt">## 6. 검증</span>
<span class="str">프롬프트:</span> "리팩토링 전후를 비교해주세요:
- 코드 라인 수
- 순환 복잡도
- 테스트 커버리지
- 성능 (벤치마크)"</code></pre>
  </div>

  <h3 id="workflow-debugging">워크플로우 3: 체계적 디버깅</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">디버깅 체크리스트</span>
    </div>
    <pre><code><span class="cmt">## 1. 재현 가능한 테스트 케이스</span>
<span class="str">프롬프트:</span> "이 버그를 재현하는 최소한의 테스트 케이스를 작성해주세요.

<span class="cmt"># 버그 설명</span>
특정 입력에서만 간헐적으로 발생
에러 메시지: [에러 메시지]
스택 트레이스: [스택 트레이스]"

<span class="cmt">## 2. 원인 가설 수립</span>
<span class="str">프롬프트:</span> "가능한 원인을 우선순위별로 나열해주세요:
1. [가능성 높음]
2. [가능성 중간]
3. [가능성 낮음]

각 가설에 대한 검증 방법도 제시"

<span class="cmt">## 3. 로깅 추가</span>
<span class="str">프롬프트:</span> "디버깅을 위한 로깅을 추가해주세요:
- 함수 입출력
- 중요 변수 값
- 분기 조건
- 성능 측정 (타임스탬프)"

<span class="cmt">## 4. 이분 탐색 디버깅</span>
<span class="str">프롬프트:</span> "코드의 절반씩 주석 처리하며 문제 위치를 좁혀주세요.
1단계: 전체 → 버그 발생
2단계: 앞쪽 절반 주석 → 버그 발생/미발생?
3단계: ...
최종: 버그 발생 라인 특정"

<span class="cmt">## 5. 수정 및 검증</span>
<span class="str">프롬프트:</span> "버그를 수정하고 다음을 확인해주세요:
1. 재현 테스트 케이스 통과
2. 기존 테스트 모두 통과
3. 유사한 버그가 다른 곳에도 있는지 검색
4. 재발 방지 방법 (정적 분석, 추가 테스트)"

<span class="cmt">## 6. 사후 분석</span>
<span class="str">프롬프트:</span> "버그 리포트를 작성해주세요:
- 원인: 왜 발생했는가?
- 해결책: 어떻게 수정했는가?
- 예방책: 같은 실수를 어떻게 방지할 것인가?
- 배운 점"</code></pre>
  </div>

  <h3 id="workflow-performance">워크플로우 4: 성능 최적화</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">성능 튜닝 프로세스</span>
    </div>
    <pre><code><span class="cmt">## 1. 프로파일링</span>
<span class="str">프롬프트:</span> "이 코드를 프로파일링하는 스크립트를 작성해주세요:
- Python: cProfile + snakeviz
- 시간이 오래 걸리는 함수 Top 10
- 메모리 사용량 측정 (memory_profiler)"

<span class="cmt">## 2. 병목 지점 파악</span>
<span class="str">프롬프트:</span> "프로파일링 결과를 분석해주세요:

[프로파일링 출력]

다음을 식별:
1. 가장 많은 시간을 소비하는 함수
2. 불필요하게 반복 호출되는 함수
3. 비효율적인 알고리즘
4. I/O 대기 시간"

<span class="cmt">## 3. 최적화 전략 수립</span>
<span class="str">프롬프트:</span> "우선순위별 최적화 전략을 제시해주세요:

<span class="cmt"># High Impact, Low Effort (먼저 수행)</span>
- 캐싱 추가
- 불필요한 DB 쿼리 제거

<span class="cmt"># High Impact, High Effort (다음 수행)</span>
- 알고리즘 개선 (O(n²) → O(n log n))
- 병렬 처리

<span class="cmt"># Low Impact (나중에 또는 스킵)</span>
- 미세한 코드 최적화"

<span class="cmt">## 4. 최적화 구현</span>
<span class="str">프롬프트:</span> "다음 최적화를 적용해주세요:
1. 반복되는 DB 쿼리를 캐싱 (Redis, TTL 5분)
2. N+1 쿼리 문제 해결 (select_related)
3. 리스트 컴프리헨션을 제너레이터로 변경
4. 정규식 컴파일 (루프 밖으로 이동)"

<span class="cmt">## 5. 벤치마크</span>
<span class="str">프롬프트:</span> "최적화 전후를 비교하는 벤치마크를 작성해주세요:
- 100, 1000, 10000개 데이터로 테스트
- 실행 시간, 메모리 사용량 측정
- 결과를 표로 출력"

<span class="cmt">## 6. 트레이드오프 문서화</span>
<span class="str">프롬프트:</span> "최적화의 트레이드오프를 문서화해주세요:
- 얻은 것: 성능 향상 (50% 속도 증가)
- 잃은 것: 코드 복잡도 증가, 메모리 10% 증가
- 언제 사용: 대용량 데이터 처리 시
- 언제 피해야: 소규모 데이터, 메모리 제약 환경"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="project-patterns">프로젝트 시작 패턴</h2>

  <h3 id="project-bootstrap">패턴 7: 프로젝트 부트스트랩</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">프로젝트 초기 설정</span>
    </div>
    <pre><code><span class="cmt">## 1. 프로젝트 구조 생성</span>
<span class="str">프롬프트:</span> "Next.js 14 + TypeScript + Tailwind 프로젝트 구조를 제안해주세요.

요구사항:
- App Router 사용
- src/ 디렉토리 구조
- 컴포넌트, 훅, 유틸리티 분리
- 환경 변수 관리
- ESLint + Prettier 설정

다음 형식으로:
```
project/
  src/
    app/
    components/
    ...
```"

<span class="cmt">## 2. 기본 설정 파일</span>
<span class="str">프롬프트:</span> "다음 설정 파일을 생성해주세요:
1. tsconfig.json (strict 모드)
2. .eslintrc.json (Airbnb 스타일)
3. .prettierrc (일관된 포맷팅)
4. .env.example (필요한 환경 변수 목록)"

<span class="cmt">## 3. 공통 컴포넌트</span>
<span class="str">프롬프트:</span> "재사용 가능한 기본 컴포넌트를 생성해주세요:
- Button (variant: primary, secondary, danger)
- Input (type, validation)
- Modal (header, body, footer)
- Loading Spinner
- Toast Notification

각 컴포넌트는:
- TypeScript 타입 정의
- Tailwind CSS 스타일링
- Storybook 스토리 포함"

<span class="cmt">## 4. 유틸리티 함수</span>
<span class="str">프롬프트:</span> "자주 사용하는 유틸리티 함수를 작성해주세요:
- 날짜 포맷팅 (formatDate, relativeTime)
- 문자열 처리 (truncate, slugify)
- 숫자 포맷팅 (formatCurrency, formatNumber)
- 검증 (isEmail, isURL)

각 함수에 테스트 포함"

<span class="cmt">## 5. API 클라이언트</span>
<span class="str">프롬프트:</span> "타입 안전한 API 클라이언트를 작성해주세요:
- Axios 래퍼
- 인터셉터 (인증 토큰, 에러 처리)
- 자동 재시도
- 타입 추론"</code></pre>
  </div>

  <h3 id="project-architecture">패턴 8: 아키텍처 설계</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">아키텍처 협의</span>
    </div>
    <pre><code><span class="str">프롬프트:</span> "전자상거래 플랫폼의 백엔드 아키텍처를 설계해주세요.

<span class="cmt"># 요구사항</span>
- 예상 사용자: 10만 명
- 동시 접속: 피크 5000명
- 주요 기능: 상품 관리, 주문, 결제, 리뷰
- 확장 가능해야 함

<span class="cmt"># 다음을 포함</span>
1. 시스템 아키텍처 다이어그램 (Mermaid)
2. 기술 스택 추천 (DB, 캐시, 메시지 큐 등)
3. 마이크로서비스 vs 모놀리스 선택 근거
4. 확장 전략 (수평 확장, 샤딩 등)
5. 보안 고려사항
6. 모니터링 & 로깅 전략

<span class="cmt"># 출력 형식</span>
## 1. Overview
[전체 아키텍처 설명]

## 2. Architecture Diagram
```mermaid
[다이어그램]
```

## 3. Technology Stack
| Component | Technology | Reason |
|-----------|------------|--------|
| ... | ... | ... |

## 4. Scaling Strategy
[확장 전략]

## 5. Security
[보안 조치]"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="code-review-patterns">코드 리뷰 패턴</h2>

  <h3 id="review-comprehensive">패턴 9: 포괄적 코드 리뷰</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">코드 리뷰 프롬프트</span>
    </div>
    <pre><code>"다음 Pull Request를 리뷰해주세요.

<span class="cmt"># PR 정보</span>
- 제목: 사용자 인증 API 추가
- 변경 파일: 5개 (models.py, routes.py, schemas.py, auth.py, tests.py)
- 추가: +350줄, 삭제: -20줄

<span class="cmt"># 리뷰 기준</span>
1. <strong>기능 정확성</strong>
   - 요구사항 충족 여부
   - 엣지 케이스 처리
   - 에러 처리

2. <strong>코드 품질</strong>
   - 가독성 (네이밍, 구조)
   - DRY 원칙 준수
   - SOLID 원칙 준수

3. <strong>보안</strong>
   - SQL Injection 방지
   - XSS 방지
   - 비밀번호 해싱
   - 민감 정보 노출

4. <strong>성능</strong>
   - 불필요한 쿼리
   - N+1 문제
   - 비효율적 알고리즘

5. <strong>테스트</strong>
   - 테스트 커버리지
   - 테스트 품질
   - 누락된 테스트 케이스

6. <strong>문서화</strong>
   - Docstring
   - 주석 (필요한 곳에만)
   - README 업데이트

<span class="cmt"># 출력 형식</span>
## Summary
- 전반적 평가: [Approve / Request Changes / Comment]
- 주요 장점 3가지
- 주요 개선점 3가지

## Critical Issues (즉시 수정 필요)
- [파일명:라인] [문제]: [해결 방법]

## Suggestions (권장)
- [파일명:라인] [제안]: [이유]

## Nitpicks (선택적)
- [사소한 개선 사항]

## Positive Feedback
- [잘한 부분]

<span class="cmt"># 코드</span>
[PR diff 첨부]"</code></pre>
  </div>

  <h3 id="review-security">패턴 10: 보안 중심 리뷰</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">보안 리뷰 체크리스트</span>
    </div>
    <pre><code>"다음 코드를 보안 관점에서 리뷰해주세요.

<span class="cmt"># OWASP Top 10 체크</span>
- [ ] A01: Broken Access Control
- [ ] A02: Cryptographic Failures
- [ ] A03: Injection
- [ ] A04: Insecure Design
- [ ] A05: Security Misconfiguration
- [ ] A06: Vulnerable Components
- [ ] A07: Authentication Failures
- [ ] A08: Data Integrity Failures
- [ ] A09: Logging Failures
- [ ] A10: SSRF

<span class="cmt"># 구체적 검증 항목</span>
1. SQL Injection:
   - 파라미터화된 쿼리 사용?
   - ORM 사용?

2. XSS:
   - 사용자 입력 이스케이프?
   - Content-Type 헤더 설정?

3. 인증/인가:
   - 비밀번호 해싱 (bcrypt, scrypt)?
   - JWT 서명 검증?
   - 역할 기반 접근 제어?

4. 민감 정보:
   - 환경 변수로 관리?
   - 로그에 노출되지 않음?

5. HTTPS:
   - 쿠키에 Secure 플래그?
   - HSTS 헤더?

<span class="cmt"># 출력</span>
각 항목에 대해:
- 상태: ✅ 안전 / ⚠️ 주의 / ❌ 취약
- 설명
- 수정 방법 (취약한 경우)

<span class="cmt"># 코드</span>
[코드 첨부]"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="documentation-patterns">문서화 패턴</h2>

  <h3 id="doc-api">패턴 11: API 문서 자동 생성</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">API 문서 프롬프트</span>
    </div>
    <pre><code>"다음 API 코드를 분석하여 OpenAPI 3.0 문서를 생성해주세요.

<span class="cmt"># 코드</span>
[FastAPI 라우터 코드]

<span class="cmt"># 요구사항</span>
1. 모든 엔드포인트 문서화
2. Request/Response 스키마
3. 인증 방법 (Bearer Token)
4. 에러 응답 형식
5. 예제 포함 (curl, JavaScript, Python)
6. Rate limiting 정보

<span class="cmt"># 추가로 생성</span>
1. Markdown 사용자 가이드
2. Postman Collection
3. 통합 테스트 예제"</code></pre>
  </div>

  <h3 id="doc-readme">패턴 12: README 작성</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">README 템플릿</span>
    </div>
    <pre><code>"이 프로젝트의 README.md를 작성해주세요.

<span class="cmt"># 프로젝트 정보</span>
- 이름: E-Commerce Platform
- 목적: 중소 쇼핑몰 SaaS
- 기술 스택: Next.js, FastAPI, PostgreSQL
- 현재 상태: Beta

<span class="cmt"># 포함할 섹션</span>
1. 프로젝트 소개 (배지 포함)
2. 주요 기능
3. 스크린샷 또는 데모
4. 시작하기
   - 사전 요구사항
   - 설치 방법
   - 환경 변수 설정
   - 실행 방법
5. 사용 예제
6. API 문서 링크
7. 프로젝트 구조
8. 개발 가이드
   - 로컬 개발 환경 설정
   - 테스트 실행
   - 빌드 & 배포
9. 기여 가이드
10. 라이선스
11. 문의처

<span class="cmt"># 스타일</span>
- 간결하고 명확하게
- 코드 블록 문법 강조
- 이모지 적절히 사용
- 뱃지 (build, coverage, license 등)"</code></pre>
  </div>

  <h3 id="doc-inline">패턴 13: 인라인 문서화</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">Docstring 생성</span>
    </div>
    <pre><code>"다음 함수에 Google 스타일 docstring을 추가해주세요.

<span class="cmt"># 함수</span>
<span class="kw">def</span> <span class="fn">process_payment</span>(user_id, amount, payment_method):
    <span class="cmt"># 결제 처리 로직</span>
    <span class="kw">pass</span>

<span class="cmt"># 요구사항</span>
1. Google 스타일 docstring
2. Args: 각 파라미터 설명, 타입
3. Returns: 반환값 설명, 타입
4. Raises: 발생 가능한 예외
5. Examples: 사용 예제
6. Notes: 주의사항 (있다면)

<span class="cmt"># 예상 출력</span>
<span class="kw">def</span> <span class="fn">process_payment</span>(user_id: <span class="type">int</span>, amount: <span class="type">Decimal</span>, payment_method: <span class="type">str</span>) -&gt; <span class="type">PaymentResult</span>:
    <span class="str">"""결제를 처리합니다.

    사용자의 결제 수단으로 지정된 금액을 청구합니다.
    결제 실패 시 자동으로 3회 재시도하며, 모두 실패하면 예외를 발생시킵니다.

    Args:
        user_id (int): 사용자 ID
        amount (Decimal): 결제 금액 (소수점 2자리까지)
        payment_method (str): 결제 수단 ('card', 'bank', 'paypal')

    Returns:
        PaymentResult: 결제 결과 객체
            - transaction_id (str): 거래 ID
            - status (str): 결제 상태
            - timestamp (datetime): 처리 시각

    Raises:
        InvalidPaymentMethodError: 지원하지 않는 결제 수단
        InsufficientFundsError: 잔액 부족
        PaymentTimeoutError: 결제 타임아웃 (30초 초과)

    Examples:
        >>> result = process_payment(123, Decimal('99.99'), 'card')
        >>> print(result.status)
        'completed'

    Notes:
        - 결제 금액은 0.01 이상이어야 합니다
        - 일일 결제 한도는 사용자 등급에 따라 다릅니다
    """</span>
    <span class="kw">pass</span>"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="test-patterns">테스트 작성 패턴</h2>

  <h3 id="test-unit">패턴 14: 유닛 테스트 생성</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">테스트 자동 생성</span>
    </div>
    <pre><code>"다음 함수에 대한 포괄적인 유닛 테스트를 작성해주세요.

<span class="cmt"># 테스트 대상</span>
[함수 코드]

<span class="cmt"># 테스트 요구사항</span>
1. <strong>Happy Path</strong>: 정상 동작 (최소 3개 케이스)
2. <strong>Edge Cases</strong>:
   - 경계값 (0, 음수, 최대값)
   - 빈 입력 (빈 문자열, 빈 리스트)
   - None 입력
   - 특수 문자
3. <strong>Error Cases</strong>:
   - TypeError (잘못된 타입)
   - ValueError (유효하지 않은 값)
   - 커스텀 예외
4. <strong>Performance</strong>:
   - 대용량 입력 (1만 개 데이터)
   - 타임아웃 체크

<span class="cmt"># 테스트 구조</span>
- pytest 사용
- AAA 패턴 (Arrange-Act-Assert)
- 테스트 함수명: test_[기능]_[시나리오]_[예상결과]
- Fixture로 공통 설정 분리
- parametrize로 여러 케이스 한 번에

<span class="cmt"># 커버리지 목표</span>
- Line coverage: 100%
- Branch coverage: 95%+

<span class="cmt"># 예시 출력</span>
<span class="kw">import</span> pytest

<span class="decorator">@pytest.fixture</span>
<span class="kw">def</span> <span class="fn">sample_data</span>():
    <span class="str">"""테스트 데이터 생성"""</span>
    <span class="kw">return</span> {...}

<span class="kw">def</span> <span class="fn">test_function_name_with_valid_input_returns_expected</span>(sample_data):
    <span class="cmt"># Arrange</span>
    expected = ...

    <span class="cmt"># Act</span>
    result = <span class="fn">function_name</span>(sample_data)

    <span class="cmt"># Assert</span>
    <span class="kw">assert</span> result == expected"</code></pre>
  </div>

  <h3 id="test-integration">패턴 15: 통합 테스트</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">E2E 시나리오</span>
    </div>
    <pre><code>"사용자 회원가입부터 주문까지 E2E 테스트를 작성해주세요.

<span class="cmt"># 시나리오</span>
1. 회원가입 (POST /auth/register)
2. 이메일 인증 (GET /auth/verify?token=...)
3. 로그인 (POST /auth/login) → JWT 토큰 획득
4. 상품 목록 조회 (GET /products)
5. 장바구니 추가 (POST /cart)
6. 주문 생성 (POST /orders)
7. 결제 (POST /payments)
8. 주문 확인 (GET /orders/{id})

<span class="cmt"># 요구사항</span>
- pytest + httpx (비동기)
- 테스트 DB 사용 (격리)
- 테스트 후 롤백
- 각 단계별 응답 검증
- 최종 DB 상태 검증

<span class="cmt"># 모킹</span>
- 외부 API: 결제 게이트웨이 모킹
- 이메일 발송: SMTP 모킹
- S3 업로드: 모킹

<span class="cmt"># 실패 시나리오도 테스트</span>
- 중복 회원가입
- 잘못된 토큰
- 재고 부족
- 결제 실패"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="antipatterns">안티패턴 회피</h2>

  <h3 id="antipattern-overreliance">안티패턴 1: 과도한 의존</h3>

  <table class="comparison-table">
    <thead>
      <tr>
        <th style="width:50%">❌ 잘못된 접근</th>
        <th style="width:50%">✅ 올바른 접근</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <strong>생각 없이 복붙</strong><br>
          AI가 생성한 코드를 이해하지 않고 그대로 사용
        </td>
        <td>
          <strong>이해하고 활용</strong><br>
          "이 코드를 단계별로 설명해주세요" → 이해 후 사용
        </td>
      </tr>
      <tr>
        <td>
          <strong>테스트 생략</strong><br>
          AI가 만든 코드는 완벽하다고 가정
        </td>
        <td>
          <strong>철저한 검증</strong><br>
          반드시 테스트 작성 및 실행, 엣지 케이스 확인
        </td>
      </tr>
      <tr>
        <td>
          <strong>컨텍스트 무시</strong><br>
          프로젝트 상황을 무시하고 일반적인 코드 요청
        </td>
        <td>
          <strong>맥락 제공</strong><br>
          기술 스택, 코딩 규칙, 제약사항 명시
        </td>
      </tr>
    </tbody>
  </table>

  <h3 id="antipattern-unclear">안티패턴 2: 불명확한 요청</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">나쁜 프롬프트 예시</span>
    </div>
    <pre><code><span class="cmt"># ❌ 너무 모호함</span>
"좋은 코드 작성해줘"

<span class="cmt"># ❌ 컨텍스트 부족</span>
"API 만들어줘"

<span class="cmt"># ❌ 제약사항 없음</span>
"빠른 정렬 알고리즘 작성해줘"
<span class="cmt">→ 어떤 언어? 어떤 데이터 타입? in-place? stable?</span>

<span class="cmt"># ❌ 측정 불가능한 목표</span>
"성능을 개선해줘"
<span class="cmt">→ 어떤 메트릭? 목표값은?</span></code></pre>
  </div>

  <h3 id="antipattern-bigbang">안티패턴 3: 빅뱅 개발</h3>

  <div class="info-box warning">
    <div class="info-box-title">피해야 할 패턴</div>
    <p><strong>한 번에 모든 것을 요청</strong></p>
    <ul>
      <li>❌ "전체 앱을 만들어줘 (프론트엔드 + 백엔드 + DB + 배포)"</li>
      <li>❌ 1000줄 이상의 코드를 한 번에 생성 요청</li>
      <li>❌ 여러 복잡한 기능을 동시에 구현 요청</li>
    </ul>
    <p><strong>올바른 방법:</strong></p>
    <ul>
      <li>✅ 기능을 작은 단위로 분해</li>
      <li>✅ 각 단계별로 테스트</li>
      <li>✅ 점진적으로 복잡도 증가</li>
    </ul>
  </div>

  <h3 id="antipattern-novalidation">안티패턴 4: 검증 생략</h3>

  <table class="comparison-table">
    <thead>
      <tr>
        <th style="width:50%">❌ 위험한 습관</th>
        <th style="width:50%">✅ 안전한 습관</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>보안 코드를 검증 없이 사용</td>
        <td>"이 코드의 보안 취약점을 분석해주세요"</td>
      </tr>
      <tr>
        <td>성능 영향을 고려하지 않음</td>
        <td>"이 코드의 시간 복잡도를 분석하고 벤치마크를 작성해주세요"</td>
      </tr>
      <tr>
        <td>에러 처리 누락</td>
        <td>"모든 예외 상황을 처리하는 에러 핸들링을 추가해주세요"</td>
      </tr>
    </tbody>
  </table>

  <h3 id="antipattern-context">안티패턴 5: 컨텍스트 손실</h3>

  <div class="code-block">
    <div class="code-header">
      <span class="code-lang">컨텍스트 유지 방법</span>
    </div>
    <pre><code><span class="cmt"># ❌ 매번 새로운 대화 시작</span>
대화 1: "Python으로 함수 작성"
대화 2: "테스트 작성" <span class="cmt">(어떤 함수?)</span>
대화 3: "문서화" <span class="cmt">(무엇을?)</span>

<span class="cmt"># ✅ 하나의 대화에서 진행</span>
대화 1: "Python으로 이메일 검증 함수 작성"
대화 2: "방금 작성한 함수의 테스트를 작성해주세요"
대화 3: "이 함수를 문서화해주세요"

<span class="cmt"># ✅ 또는 명시적 참조</span>
대화 2: "다음 함수의 테스트를 작성해주세요:\n[함수 코드]"</code></pre>
  </div>
</section>

<section class="content-section">
  <h2 id="best-practices">베스트 프랙티스 요약</h2>

  <div class="info-box tip">
    <div class="info-box-title">Vibe Coding 체크리스트</div>
    <p><strong>시작 전:</strong></p>
    <ul>
      <li>✅ 요구사항을 명확히 이해했는가?</li>
      <li>✅ 프로젝트 컨텍스트를 정리했는가?</li>
      <li>✅ 작은 단위로 쪼갤 수 있는가?</li>
    </ul>
    <p><strong>진행 중:</strong></p>
    <ul>
      <li>✅ 각 단계별로 검증하는가?</li>
      <li>✅ 생성된 코드를 이해하는가?</li>
      <li>✅ 테스트를 작성하는가?</li>
    </ul>
    <p><strong>완료 후:</strong></p>
    <ul>
      <li>✅ 코드 리뷰를 받았는가?</li>
      <li>✅ 문서화했는가?</li>
      <li>✅ 배운 점을 기록했는가?</li>
    </ul>
  </div>
</section>

<section class="content-section">
  <h2 id="next-steps">다음 단계</h2>

  <div class="info-box info">
    <div class="info-box-title">학습 경로</div>
    <p><strong>Vibe Coding을 마스터한 후:</strong></p>
    <ol>
      <li><a href="claude-cli.html">Claude Code</a> - CLI 기반 개발 환경</li>
      <li><a href="claude-api.html">Tool Use</a> - 외부 도구 통합</li>
      <li><a href="mcp-intro.html">Model Context Protocol</a> - 고급 컨텍스트 관리</li>
      <li><a href="resources.html">참고 자료</a> - 추가 학습 리소스</li>
    </ol>
  </div>
</section>

<section class="content-section">
  <h2 id="summary">핵심 정리</h2>
  <ul>
    <li>Vibe Coding 패턴의 핵심 개념과 흐름을 정리합니다.</li>
    <li>Vibe Coding이란?를 단계별로 이해합니다.</li>
    <li>실전 적용 시 기준과 주의점을 확인합니다.</li>
  </ul>
</section>

<section class="content-section">
  <h2 id="practice-tips">실무 팁</h2>
  <ul>
    <li>입력/출력 예시를 고정해 재현성을 확보하세요.</li>
    <li>Vibe Coding 패턴 범위를 작게 잡고 단계적으로 확장하세요.</li>
    <li>Vibe Coding이란? 조건을 문서화해 대응 시간을 줄이세요.</li>
  </ul>
</section>
<nav class="page-nav"></nav>

</main>

<aside class="inline-toc">
  <div class="toc-title">목차</div>
  <div class="toc-nav"></div>
</aside>

<footer class="site-footer"></footer>

</div>

<script src="../js/main.js"></script>
</body>
</html>
